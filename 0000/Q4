import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Enter the value of N (size of the chessboard): ");
        int n = input.nextInt();
        input.close();

        int[][] board = new int[n][n]; // 0 means empty, 1 means queen

        if (solveNQueens(board, 0, n)) {
            System.out.println("One valid arrangement of queens:");
            printBoard(board, n);
        } else {
            System.out.println("No solution exists for N = " + n);
        }
    }

    // -------------------- Recursive Solver --------------------
    /**
     * The solveNQueens() function tries to place queens one column at a time.
     * It uses recursion to explore possible placements and backtracking to undo invalid ones.
     *
     * Why Recursion:
     * Each step depends on the smaller subproblem (placing a queen in the next column),
     * so recursion naturally expresses the process of exploring all valid combinations.
     */
    public static boolean solveNQueens(int[][] board, int col, int n) {
        // Base case: all queens are placed
        if (col == n) {
            return true;
        }

        // Try placing a queen in each row for this column
        for (int row = 0; row < n; row++) {
            if (isSafe(board, row, col, n)) {
                board[row][col] = 1; // Place the queen

                // Recurse to place the rest of the queens
                if (solveNQueens(board, col + 1, n)) {
                    return true;
                }

                /**
                 * Backtracking step:
                 * If placing the queen here leads to no solution,
                 * remove it ("undo" the move) and try the next position.
                 */
                board[row][col] = 0;
            }
        }

        // If the queen cannot be placed in any row in this column, backtrack
        return false;
    }

    // -------------------- Safety Check --------------------
    /**
     * The isSafe() function checks if placing a queen at (row, col)
     * will not be attacked by another queen.
     * We check only:
     *   - Left side of the current row
     *   - Upper-left diagonal
     *   - Lower-left diagonal
     * Because we place queens column by column from left to right.
     */
    public static boolean isSafe(int[][] board, int row, int col, int n) {
        // Check same row on the left side
        for (int i = 0; i < col; i++) {
            if (board[row][i] == 1)
                return false;
        }

        // Check upper-left diagonal
        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 1)
                return false;
        }

        // Check lower-left diagonal
        for (int i = row, j = col; i < n && j >= 0; i++, j--) {
            if (board[i][j] == 1)
                return false;
        }

        return true;
    }

    // -------------------- Print Board --------------------
    public static void printBoard(int[][] board, int n) {
        for (int[] row : board) {
            for (int cell : row) {
                System.out.print(cell == 1 ? "Q " : ". ");
            }
            System.out.println();
        }
    }
}
